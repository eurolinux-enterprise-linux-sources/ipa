From 378f9b72ab238fa719ba8f92645edff915b6ce59 Mon Sep 17 00:00:00 2001
From: Rob Crittenden <rcritten@redhat.com>
Date: Wed, 12 Sep 2012 10:43:16 -0400
Subject: [PATCH 5/8] Remove Entitlement support

---
 API.txt                               |   63 ---
 freeipa.spec.in                       |    4 -
 install/share/bootstrap-template.ldif |    6 -
 install/share/delegation.ldif         |   80 ----
 install/tools/Makefile.am             |    1 -
 install/tools/ipa-compliance          |  201 ---------
 install/tools/man/Makefile.am         |    2 +-
 install/tools/man/ipa-compliance.1    |   45 --
 ipa-compliance.cron                   |    5 -
 ipalib/constants.py                   |    1 -
 ipalib/plugins/entitle.py             |  748 ---------------------------------
 ipalib/plugins/internal.py            |   21 -
 12 files changed, 1 insertions(+), 1176 deletions(-)
 delete mode 100644 install/tools/ipa-compliance
 delete mode 100644 install/tools/man/ipa-compliance.1
 delete mode 100644 ipa-compliance.cron
 delete mode 100644 ipalib/plugins/entitle.py

diff --git a/API.txt b/API.txt
index 318453f..f90c217 100644
--- a/API.txt
+++ b/API.txt
@@ -1142,69 +1142,6 @@ option: Str('version?', exclude='webui')
 output: Output('summary', (<type 'unicode'>, <type 'NoneType'>), None)
 output: Entry('result', <type 'dict'>, Gettext('A dictionary representing an LDAP entry', domain='ipa', localedir=None))
 output: Output('value', <type 'unicode'>, None)
-command: entitle_consume
-args: 1,4,3
-arg: Int('quantity', minvalue=1)
-option: Int('hidden', autofill=True, default=1, minvalue=1)
-option: Flag('all', autofill=True, cli_name='all', default=False, exclude='webui')
-option: Flag('raw', autofill=True, cli_name='raw', default=False, exclude='webui')
-option: Str('version?', exclude='webui')
-output: Output('summary', (<type 'unicode'>, <type 'NoneType'>), None)
-output: Entry('result', <type 'dict'>, Gettext('A dictionary representing an LDAP entry', domain='ipa', localedir=None))
-output: Output('value', <type 'unicode'>, None)
-command: entitle_find
-args: 1,5,4
-arg: Str('criteria?', noextrawhitespace=False)
-option: Int('timelimit?', autofill=False, minvalue=0)
-option: Int('sizelimit?', autofill=False, minvalue=0)
-option: Flag('all', autofill=True, cli_name='all', default=False, exclude='webui')
-option: Flag('raw', autofill=True, cli_name='raw', default=False, exclude='webui')
-option: Str('version?', exclude='webui')
-output: Output('summary', (<type 'unicode'>, <type 'NoneType'>), None)
-output: ListOfEntries('result', (<type 'list'>, <type 'tuple'>), Gettext('A list of LDAP entries', domain='ipa', localedir=None))
-output: Output('count', <type 'int'>, None)
-output: Output('truncated', <type 'bool'>, None)
-command: entitle_get
-args: 0,3,4
-option: Flag('all', autofill=True, cli_name='all', default=False, exclude='webui')
-option: Flag('raw', autofill=True, cli_name='raw', default=False, exclude='webui')
-option: Str('version?', exclude='webui')
-output: Output('summary', (<type 'unicode'>, <type 'NoneType'>), None)
-output: ListOfEntries('result', (<type 'list'>, <type 'tuple'>), Gettext('A list of LDAP entries', domain='ipa', localedir=None))
-output: Output('count', <type 'int'>, None)
-output: Output('truncated', <type 'bool'>, None)
-command: entitle_import
-args: 1,3,1
-arg: File('usercertificate*', cli_name='certificate_file')
-option: Str('setattr*', cli_name='setattr', exclude='webui')
-option: Str('addattr*', cli_name='addattr', exclude='webui')
-option: Str('uuid?', autofill=True, default=u'IMPORTED')
-output: Output('result', <type 'dict'>, None)
-command: entitle_register
-args: 1,7,3
-arg: Str('username')
-option: Str('setattr*', cli_name='setattr', exclude='webui')
-option: Str('addattr*', cli_name='addattr', exclude='webui')
-option: Str('ipaentitlementid?')
-option: Password('password', confirm=False)
-option: Flag('all', autofill=True, cli_name='all', default=False, exclude='webui')
-option: Flag('raw', autofill=True, cli_name='raw', default=False, exclude='webui')
-option: Str('version?', exclude='webui')
-output: Output('summary', (<type 'unicode'>, <type 'NoneType'>), None)
-output: Entry('result', <type 'dict'>, Gettext('A dictionary representing an LDAP entry', domain='ipa', localedir=None))
-output: Output('value', <type 'unicode'>, None)
-command: entitle_status
-args: 0,0,1
-output: Output('result', <type 'dict'>, None)
-command: entitle_sync
-args: 0,4,3
-option: Int('hidden', autofill=True, default=1, minvalue=1)
-option: Flag('all', autofill=True, cli_name='all', default=False, exclude='webui')
-option: Flag('raw', autofill=True, cli_name='raw', default=False, exclude='webui')
-option: Str('version?', exclude='webui')
-output: Output('summary', (<type 'unicode'>, <type 'NoneType'>), None)
-output: Entry('result', <type 'dict'>, Gettext('A dictionary representing an LDAP entry', domain='ipa', localedir=None))
-output: Output('value', <type 'unicode'>, None)
 command: env
 args: 1,2,4
 arg: Str('variables*')
diff --git a/freeipa.spec.in b/freeipa.spec.in
index dee262b..2c775b9 100644
--- a/freeipa.spec.in
+++ b/freeipa.spec.in
@@ -443,7 +443,6 @@ mkdir -p %{buildroot}/%{_localstatedir}/lib/ipa-client/sysrestore
 mkdir -p %{buildroot}%{_sysconfdir}/bash_completion.d
 install -pm 644 contrib/completion/ipa.bash_completion %{buildroot}%{_sysconfdir}/bash_completion.d/ipa
 mkdir -p %{buildroot}%{_sysconfdir}/cron.d
-install -pm 644 ipa-compliance.cron %{buildroot}%{_sysconfdir}/cron.d/ipa-compliance
 
 (cd %{buildroot}/%{python_sitelib}/ipaserver && find . -type f  | \
 	grep -v dcerpc | grep -v adtrustinstance | \
@@ -575,9 +574,7 @@ fi
 %{_sbindir}/ipa-managed-entries
 %{_sbindir}/ipactl
 %{_sbindir}/ipa-upgradeconfig
-%{_sbindir}/ipa-compliance
 %{_libexecdir}/certmonger/dogtag-ipa-retrieve-agent-submit
-%{_sysconfdir}/cron.d/ipa-compliance
 %config(noreplace) %{_sysconfdir}/sysconfig/ipa_memcached
 %dir %attr(0700,apache,apache) %{_localstatedir}/run/ipa_memcached/
 %if 0%{?fedora} >= 15
@@ -681,7 +678,6 @@ fi
 %{_mandir}/man1/ipa-ldap-updater.1.gz
 %{_mandir}/man8/ipactl.8.gz
 %{_mandir}/man8/ipa-upgradeconfig.8.gz
-%{_mandir}/man1/ipa-compliance.1.gz
 
 %files server-selinux
 %defattr(-,root,root,-)
diff --git a/install/share/bootstrap-template.ldif b/install/share/bootstrap-template.ldif
index aac3f05..ae722df 100644
--- a/install/share/bootstrap-template.ldif
+++ b/install/share/bootstrap-template.ldif
@@ -125,12 +125,6 @@ objectClass: nsContainer
 objectClass: top
 cn: sysaccounts
 
-dn: cn=entitlements,cn=etc,$SUFFIX
-changetype: add
-objectClass: nsContainer
-objectClass: top
-cn: entitlements
-
 dn: cn=ipa,cn=etc,$SUFFIX
 changetype: add
 objectClass: nsContainer
diff --git a/install/share/delegation.ldif b/install/share/delegation.ldif
index f62062f..1ebe2f9 100644
--- a/install/share/delegation.ldif
+++ b/install/share/delegation.ldif
@@ -37,23 +37,6 @@ objectClass: nestedgroup
 cn: helpdesk
 description: Helpdesk
 
-dn: cn=Entitlement Management,cn=roles,cn=accounts,$SUFFIX
-changetype: add
-objectClass: top
-objectClass: groupofnames
-objectClass: nestedgroup
-cn: Entitlement Management
-description: Entitlements administrator
-
-dn: cn=Entitlement Compliance,cn=roles,cn=accounts,$SUFFIX
-changetype: add
-objectClass: top
-objectClass: groupofnames
-objectClass: nestedgroup
-cn: Entitlement Compliance
-description: Verify entitlement compliance
-member: fqdn=$FQDN,cn=computers,cn=accounts,$SUFFIX
-
 ############################################
 # Add the default privileges
 ############################################
@@ -146,26 +129,6 @@ objectClass: nestedgroup
 cn: Host Enrollment
 description: Host Enrollment
 
-dn: cn=Register and Write Entitlements,cn=privileges,cn=pbac,$SUFFIX
-changetype: add
-objectClass: top
-objectClass: groupofnames
-objectClass: nestedgroup
-cn: Register and Write Entitlements
-description: Register and Write Entitlements
-member: cn=Entitlement Management,cn=roles,cn=accounts,$SUFFIX
-
-dn: cn=Read Entitlements,cn=privileges,cn=pbac,$SUFFIX
-changetype: add
-objectClass: top
-objectClass: groupofnames
-objectClass: nestedgroup
-cn: Read Entitlements
-description: Read Entitlements
-member: cn=Entitlement Management,cn=roles,cn=accounts,$SUFFIX
-member: cn=Entitlement Compliance,cn=roles,cn=accounts,$SUFFIX
-
-
 ############################################
 # Default permissions.
 ############################################
@@ -545,32 +508,6 @@ cn: Remove Replication Agreements
 ipapermissiontype: SYSTEM
 member: cn=Replication Administrators,cn=privileges,cn=pbac,$SUFFIX
 
-# Entitlement management
-
-dn: cn=Register Entitlements,cn=permissions,cn=pbac,$SUFFIX
-changetype: add
-objectClass: top
-objectClass: groupofnames
-objectClass: ipapermission
-cn: Register Entitlements
-member: cn=Register and Write Entitlements,cn=privileges,cn=pbac,$SUFFIX
-
-dn: cn=Read Entitlements,cn=permissions,cn=pbac,$SUFFIX
-changetype: add
-objectClass: top
-objectClass: groupofnames
-objectClass: ipapermission
-cn: Read Entitlements
-member: cn=Read Entitlements,cn=privileges,cn=pbac,$SUFFIX
-
-dn: cn=Write Entitlements,cn=permissions,cn=pbac,$SUFFIX
-changetype: add
-objectClass: top
-objectClass: groupofnames
-objectClass: ipapermission
-cn: Write Entitlements
-member: cn=Register and Write Entitlements,cn=privileges,cn=pbac,$SUFFIX
-
 ############################################
 # Default permissions (ACIs)
 ############################################
@@ -692,23 +629,6 @@ changetype: modify
 add: aci
 aci: (targetattr = "objectclass")(target = "ldap:///fqdn=*,cn=computers,cn=accounts,$SUFFIX")(version 3.0;acl "permission:Enroll a host";allow (write) groupdn = "ldap:///cn=Enroll a host,cn=permissions,cn=pbac,$SUFFIX";)
 
-# Entitlement administration
-
-dn: $SUFFIX
-changetype: modify
-add: aci
-aci: (target = "ldap:///ipaentitlementid=*,cn=entitlements,cn=etc,$SUFFIX")(version 3.0;acl "permission:Register Entitlements";allow (add) groupdn = "ldap:///cn=Register Entitlements,cn=permissions,cn=pbac,$SUFFIX";)
-
-dn: $SUFFIX
-changetype: modify
-add: aci
-aci: (targetattr = "usercertificate")(target = "ldap:///ipaentitlement=*,cn=entitlements,cn=etc,$SUFFIX")(version 3.0;acl "permission:Write Entitlements";allow (write) groupdn = "ldap:///cn=Write Entitlements,cn=permissions,cn=pbac,$SUFFIX";)
-
-dn: $SUFFIX
-changetype: modify
-add: aci
-aci: (targetattr = "userpkcs12")(target = "ldap:///ipaentitlementid=*,cn=entitlements,cn=etc,$SUFFIX")(version 3.0;acl "permission:Read Entitlements";allow (read) groupdn = "ldap:///cn=Read Entitlements,cn=permissions,cn=pbac,$SUFFIX";)
-
 # Create virtual operations entry. This is used to control access to
 # operations that don't rely on LDAP directly.
 dn: cn=virtual operations,cn=etc,$SUFFIX
diff --git a/install/tools/Makefile.am b/install/tools/Makefile.am
index 7f1504c..d5f0a64 100644
--- a/install/tools/Makefile.am
+++ b/install/tools/Makefile.am
@@ -21,7 +21,6 @@ sbin_SCRIPTS =			\
 	ipa-managed-entries     \
 	ipa-ldap-updater	\
 	ipa-upgradeconfig	\
-	ipa-compliance		\
 	$(NULL)
 
 EXTRA_DIST =			\
diff --git a/install/tools/ipa-compliance b/install/tools/ipa-compliance
deleted file mode 100644
index c82e415..0000000
--- a/install/tools/ipa-compliance
+++ /dev/null
@@ -1,201 +0,0 @@
-#!/usr/bin/env python
-#
-# Authors:
-#   Rob Crittenden <rcritten@redhat.com>
-#
-# Copyright (C) 2010  Red Hat
-# see file 'COPYING' for use and warranty information
-#
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program.  If not, see <http://www.gnu.org/licenses/>.
-#
-# An LDAP client to count entitlements and log to syslog if the number is
-# exceeded.
-
-try:
-    import sys
-    import os
-    import syslog
-    import tempfile
-    import krbV
-    import base64
-    import shutil
-
-    from rhsm.certificate import EntitlementCertificate
-
-    from ipaserver.plugins.ldap2 import ldap2
-    from ipalib import api, errors, backend
-    from ipaserver.install import installutils
-    from ipapython.dn import DN
-except ImportError, e:
-    # If python-rhsm isn't installed exit gracefully and quietly.
-    if e.args[0] == 'No module named rhsm.certificate':
-        sys.exit(0)
-    print >> sys.stderr, """\
-There was a problem importing one of the required Python modules. The
-error was:
-
-    %s
-""" % sys.exc_value
-    sys.exit(1)
-
-# Each IPA server comes with this many entitlements
-DEFAULT_ENTITLEMENTS = 25
-
-class client(backend.Executioner):
-    """
-    A simple-minded IPA client that can execute remote commands.
-    """
-
-    def run(self, method, **kw):
-        self.create_context()
-        result = self.execute(method, **kw)
-        return result
-
-def parse_options():
-    from optparse import OptionParser
-
-    parser = OptionParser()
-    parser.add_option("--debug", dest="debug", action="store_true",
-        default=False, help="enable debugging")
-
-    options, args = parser.parse_args()
-    return options, args
-
-def check_compliance(tmpdir, debug=False):
-    cfg = dict(
-        context='cli',
-        in_server=False,
-        debug=debug,
-        verbose=0,
-    )
-
-    api.bootstrap(**cfg)
-    api.register(client)
-    api.finalize()
-    from ipalib.x509 import normalize_certificate, make_pem
-
-    try:
-        # Create a new credentials cache for this tool. This executes
-        # using the systems host principal.
-        ccache_file = 'FILE:%s/ccache' % tmpdir
-        krbcontext = krbV.default_context()
-        principal = str('host/%s@%s' % (api.env.host, api.env.realm))
-        keytab = krbV.Keytab(name='/etc/krb5.keytab', context=krbcontext)
-        principal = krbV.Principal(name=principal, context=krbcontext)
-        os.environ['KRB5CCNAME'] = ccache_file
-        ccache = krbV.CCache(name=ccache_file, context=krbcontext, primary_principal=principal)
-        ccache.init(principal)
-        ccache.init_creds_keytab(keytab=keytab, principal=principal)
-    except krbV.Krb5Error, e:
-        raise StandardError('Error initializing principal %s in %s: %s' % (principal.name, '/etc/krb5.keytab', str(e)))
-
-    # entitle-sync doesn't return any information we want to see, it just
-    # needs to be done so the LDAP data is correct.
-    try:
-        result = api.Backend.client.run('entitle_sync')
-    except errors.NotRegisteredError:
-        # Even if not registered they have some default entitlements
-        pass
-
-    conn = ldap2(shared_instance=False)
-
-    # Bind using GSSAPI
-    conn.connect(ccache=ccache_file)
-
-    hostcount = 0
-    # Get the hosts first
-    try:
-        (entries, truncated) = conn.find_entries('(krblastpwdchange=*)', ['dn'],
-            DN(api.env.container_host, api.env.basedn),
-            conn.SCOPE_ONELEVEL,
-            size_limit = -1)
-    except errors.NotFound:
-         # No hosts
-         pass
-
-    if not truncated:
-        hostcount = len(entries)
-    else:
-        # This will not happen unless we bump into a server-side limit.
-        msg = 'The host count result was truncated, they will be underreported'
-        syslog.syslog(syslog.LOG_ERR, msg)
-        if sys.stdin.isatty():
-            print msg
-
-    available = 0
-    try:
-        (entries, truncated) = conn.find_entries('(objectclass=ipaentitlement)',
-        ['dn', 'userCertificate'],
-        DN(api.env.container_entitlements, api.env.basedn),
-        conn.SCOPE_ONELEVEL,
-        size_limit = -1)
-
-        for entry in entries:
-            (dn, attrs) = entry
-            if 'usercertificate' in attrs:
-                rawcert = attrs['usercertificate'][0]
-                rawcert = normalize_certificate(rawcert)
-                cert = make_pem(base64.b64encode(rawcert))
-                cert = EntitlementCertificate(cert)
-                order = cert.getOrder()
-                available += int(order.getQuantityUsed())
-    except errors.NotFound:
-        pass
-
-    conn.disconnect()
-
-    available += DEFAULT_ENTITLEMENTS
-
-    if hostcount > available:
-        syslog.syslog(syslog.LOG_ERR, 'IPA is out of compliance: %d of %d entitlements used.' % (hostcount, available))
-        if sys.stdin.isatty():
-            print 'IPA is out of compliance: %d of %d entitlements used.' % (hostcount, available)
-    else:
-        if sys.stdin.isatty():
-            # If run from the command-line display some info
-            print 'IPA is in compliance: %d of %d entitlements used.' % (hostcount, available)
-
-def main():
-    installutils.check_server_configuration()
-
-    if not os.path.exists('/etc/ipa/default.conf'):
-        return 0
-
-    options, args = parse_options()
-
-    try:
-        tmpdir = tempfile.mkdtemp(prefix = "tmp-")
-        try:
-            check_compliance(tmpdir, options.debug)
-        finally:
-            shutil.rmtree(tmpdir)
-    except KeyboardInterrupt:
-        return 1
-    except (StandardError, errors.PublicError), e:
-        syslog.syslog(syslog.LOG_ERR, 'IPA compliance checking failed: %s' % str(e))
-        if sys.stdin.isatty():
-            print 'IPA compliance checking failed: %s' % str(e)
-        return 1
-
-    return 0
-
-try:
-    if not os.geteuid()==0:
-        sys.exit("\nMust be root to check compliance\n")
-
-    main()
-except SystemExit, e:
-    sys.exit(e)
-except RuntimeError, e:
-    sys.exit(e)
diff --git a/install/tools/man/Makefile.am b/install/tools/man/Makefile.am
index 8d5d416..a667038 100644
--- a/install/tools/man/Makefile.am
+++ b/install/tools/man/Makefile.am
@@ -19,7 +19,7 @@ man1_MANS = 				\
 	ipa-compat-manage.1		\
 	ipa-nis-manage.1		\
 	ipa-managed-entries.1		\
-	ipa-compliance.1
+        $(NULL)
 
 man8_MANS =				\
 	ipactl.8			\
diff --git a/install/tools/man/ipa-compliance.1 b/install/tools/man/ipa-compliance.1
deleted file mode 100644
index 4f8a619..0000000
--- a/install/tools/man/ipa-compliance.1
+++ /dev/null
@@ -1,45 +0,0 @@
-.\" A man page for ipa-compliance
-.\" Copyright (C) 2010 Red Hat, Inc.
-.\"
-.\" This is free software; you can redistribute it and/or modify it under
-.\" the terms of the GNU Library General Public License as published by
-.\" the Free Software Foundation; version 2 only
-.\"
-.\" This program is distributed in the hope that it will be useful, but
-.\" WITHOUT ANY WARRANTY; without even the implied warranty of
-.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-.\" General Public License for more details.
-.\"
-.\" You should have received a copy of the GNU Library General Public
-.\" License along with this program; if not, write to the Free Software
-.\" Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-.\"
-.\" Author: Rob Crittenden <rcritten@redhat.com>
-.\"
-.TH "ipa-compliance" "1" "Dec 14 2010" "FreeIPA" "FreeIPA Manual Pages"
-.SH "NAME"
-ipa\-compliance \- Check entitlement compliance
-.SH "SYNOPSIS"
-ipa\-compliance [\fIOPTION\fR]
-.SH "DESCRIPTION"
-Verify that the IPA installation is in compliance with the number of client entitlements it has.
-
-Entitlements are managed using the ipa entitle command.
-
-An enrolled host is an machine that has a host keytab in the IPA system.
-
-The entitlements take the form of x509v3 certificates. The certificates are examined and the quantities summed. This is compared to the number of enrolled hosts to determine compliance.
-
-The command logs to syslog and if run from a tty will log to the terminal as well.
-
-The IPA server provides 25 entitlements of its own.
-.SH "OPTIONS"
-.TP
-\fB\-\-debug\fR
-Enable debugging output in the command
-.SH "EXIT STATUS"
-0 if the command was successful
-
-1 if an error occurred
-.SH "NOTES"
-Entitlements are not checked if the python\-rhsm package is not installed.
diff --git a/ipa-compliance.cron b/ipa-compliance.cron
deleted file mode 100644
index 662f560..0000000
--- a/ipa-compliance.cron
+++ /dev/null
@@ -1,5 +0,0 @@
-SHELL=/bin/bash
-PATH=/sbin:/bin:/usr/sbin:/usr/bin
-MAILTO=root
-HOME=/
-0 0-23/4 * * * root /usr/sbin/ipa-compliance
diff --git a/ipalib/constants.py b/ipalib/constants.py
index 5964986..1d76af6 100644
--- a/ipalib/constants.py
+++ b/ipalib/constants.py
@@ -98,7 +98,6 @@ DEFAULT_CONFIG = (
     ('container_sudorule', DN(('cn', 'sudorules'), ('cn', 'sudo'))),
     ('container_sudocmd', DN(('cn', 'sudocmds'), ('cn', 'sudo'))),
     ('container_sudocmdgroup', DN(('cn', 'sudocmdgroups'), ('cn', 'sudo'))),
-    ('container_entitlements', DN(('cn', 'entitlements'), ('cn', 'etc'))),
     ('container_automember', DN(('cn', 'automember'), ('cn', 'etc'))),
     ('container_selinux', DN(('cn', 'usermap'), ('cn', 'selinux'))),
     ('container_s4u2proxy', DN(('cn', 's4u2proxy'), ('cn', 'etc'))),
diff --git a/ipalib/plugins/entitle.py b/ipalib/plugins/entitle.py
deleted file mode 100644
index 1b82105..0000000
--- a/ipalib/plugins/entitle.py
+++ /dev/null
@@ -1,748 +0,0 @@
-# Authors:
-#   Rob Crittenden <rcritten@redhat.com>
-#
-# Copyright (C) 2010  Red Hat
-# see file 'COPYING' for use and warranty information
-#
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-from ipalib import api, SkipPluginModule
-try:
-    from rhsm.connection import *
-    from rhsm.certificate import EntitlementCertificate
-    import M2Crypto
-    if api.env.in_server and api.env.context in ['lite', 'server']:
-        from ipaserver.install.certs import NSS_DIR
-except ImportError, e:
-    if not api.env.validate_api:
-        raise SkipPluginModule(reason=str(e))
-
-import os
-from ipalib import api, errors
-from ipalib import Flag, Int, Str, Password, File
-from ipalib.plugins.baseldap import *
-from ipalib.plugins.virtual import *
-from ipalib import _, ngettext
-from ipalib.output import Output, standard_list_of_entries
-from ipalib.request import context
-from ipapython import ipautil
-import tempfile
-import shutil
-import socket
-import base64
-from OpenSSL import crypto
-from ipapython.ipautil import run
-from ipalib.request import context
-from ipalib.plugins.service import validate_certificate
-from ipalib import x509
-
-import locale
-
-__doc__ = _("""
-Entitlements
-
-Manage entitlements for client machines
-
-Entitlements can be managed either by registering with an entitlement
-server with a username and password or by manually importing entitlement
-certificates. An entitlement certificate contains embedded information
-such as the product being entitled, the quantity and the validity dates.
-
-An entitlement server manages the number of client entitlements available.
-To mark these entitlements as used by the IPA server you provide a quantity
-and they are marked as consumed on the entitlement server.
-
- Register with an entitlement server:
-   ipa entitle-register consumer
-
- Import an entitlement certificate:
-   ipa entitle-import /home/user/ipaclient.pem
-
- Display current entitlements:
-   ipa entitle-status
-
- Retrieve details on entitlement certificates:
-   ipa entitle-get
-
- Consume some entitlements from the entitlement server:
-   ipa entitle-consume 50
-
-The registration ID is a Unique Identifier (UUID). This ID will be
-IMPORTED if you have used entitle-import.
-
-Changes to /etc/rhsm/rhsm.conf require a restart of the httpd service.
-""")
-
-def read_file(filename):
-    fp = open(filename, 'r')
-    data = fp.readlines()
-    fp.close()
-    data = ''.join(data)
-    return data
-
-def write_file(filename, pem):
-    cert_file = open(filename, 'w')
-    cert_file.write(pem)
-    cert_file.close()
-
-def read_pkcs12_pin():
-    pwdfile = '%s/pwdfile.txt' % NSS_DIR
-    fp = open(pwdfile, 'r')
-    pwd = fp.read()
-    fp.close()
-    return pwd
-
-def get_pool(ldap):
-    """
-    Get our entitlement pool. Assume there is only one pool.
-    """
-    db = None
-    try:
-        (db, uuid, certfile, keyfile) = get_uuid(ldap)
-        if db is None:
-            # db is None means manual registration
-            return (None, uuid)
-
-        cp = UEPConnection(handler='/candlepin', cert_file=certfile, key_file=keyfile)
-
-        pools = cp.getPoolsList(uuid)
-        poolid = pools[0]['id']
-
-        pool = cp.getPool(poolid)
-    finally:
-        if db:
-            shutil.rmtree(db, ignore_errors=True)
-
-    return (pool, uuid)
-
-def get_uuid(ldap):
-    """
-    Retrieve our UUID, certificate and key from LDAP.
-
-    Except on error the caller is responsible for removing temporary files
-    """
-    db = None
-    try:
-        db = tempfile.mkdtemp(prefix = "tmp-")
-        registrations = api.Command['entitle_find'](all=True)
-        if registrations['count'] == 0:
-            shutil.rmtree(db, ignore_errors=True)
-            raise errors.NotRegisteredError()
-        result = registrations['result'][0]
-        uuid = str(result['ipaentitlementid'][0])
-
-        entry_attrs = dict(ipaentitlementid=uuid)
-        dn = ldap.make_dn(
-            entry_attrs, 'ipaentitlementid', api.env.container_entitlements,
-        )
-        if not ldap.can_read(dn, 'userpkcs12'):
-            raise errors.ACIError(
-                info=_('not allowed to perform this command'))
-
-        if not 'userpkcs12' in result:
-            return (None, uuid, None, None)
-        data = result['userpkcs12'][0]
-        pkcs12 = crypto.load_pkcs12(data, read_pkcs12_pin())
-        cert = pkcs12.get_certificate()
-        key = pkcs12.get_privatekey()
-        write_file(db + '/cert.pem',
-            crypto.dump_certificate(crypto.FILETYPE_PEM, cert))
-        write_file(db + '/key.pem',
-            crypto.dump_privatekey(crypto.FILETYPE_PEM, key))
-    except Exception, e:
-        if db is not None:
-            shutil.rmtree(db, ignore_errors=True)
-        raise e
-
-    return (db, uuid, db + '/cert.pem', db + '/key.pem')
-
-output_params = (
-    Str('ipaentitlementid?',
-        label='UUID',
-    ),
-    Str('usercertificate',
-        label=_('Certificate'),
-    ),
-)
-
-class entitle(LDAPObject):
-    """
-    Entitlement object
-    """
-    container_dn = api.env.container_entitlements
-    object_name = _('entitlement')
-    object_name_plural = _('entitlements')
-    object_class = ['ipaobject', 'ipaentitlement']
-    search_attributes = ['usercertificate']
-    default_attributes = ['ipaentitlement']
-    uuid_attribute = 'ipaentitlementid'
-
-    label = _('Entitlements')
-    label_singular = _('Entitlement')
-
-    """
-    def get_dn(self, *keys, **kwargs):
-        try:
-            (dn, entry_attrs) = self.backend.find_entry_by_attr(
-                self.primary_key.name, keys[-1], self.object_class, [''],
-                self.container_dn
-            )
-        except errors.NotFound:
-            dn = super(entitle, self).get_dn(*keys, **kwargs)
-        return dn
-    """
-
-api.register(entitle)
-
-class entitle_status(VirtualCommand):
-    __doc__ = _('Display current entitlements.')
-
-    operation="show entitlement"
-
-    has_output_params = (
-        Str('uuid',
-            label=_('UUID'),
-        ),
-        Str('product',
-            label=_('Product'),
-        ),
-        Int('quantity',
-            label=_('Quantity'),
-        ),
-        Int('consumed',
-            label=_('Consumed'),
-        ),
-    )
-
-    has_output = (
-        Output('result',
-            type=dict,
-            doc=_('Dictionary mapping variable name to value'),
-        ),
-    )
-
-    def execute(self, *keys, **kw):
-        ldap = self.api.Backend.ldap2
-
-        os.environ['LANG'] = 'en_US'
-        locale.setlocale(locale.LC_ALL, '')
-
-        (pool, uuid) = get_pool(ldap)
-
-        if pool is None:
-            # This assumes there is only 1 product
-            quantity = 0
-            product = ''
-            registrations = api.Command['entitle_find'](all=True)['result'][0]
-            if u'usercertificate' in registrations:
-                certs = registrations['usercertificate']
-                for cert in certs:
-                    cert = x509.make_pem(base64.b64encode(cert))
-                    try:
-                        pc = EntitlementCertificate(cert)
-                        o = pc.getOrder()
-                        if o.getQuantityUsed():
-                            quantity = quantity + int(o.getQuantityUsed())
-                        product = o.getName()
-                    except M2Crypto.X509.X509Error, e:
-                        self.error('Invalid entitlement certificate, skipping.')
-            pool = dict(productId=product, quantity=quantity,
-                consumed=quantity, uuid=unicode(uuid))
-
-        result={'product': unicode(pool['productId']),
-            'quantity': pool['quantity'],
-            'consumed': pool['consumed'],
-            'uuid': unicode(uuid),
-        }
-
-        return dict(
-            result=result
-        )
-
-api.register(entitle_status)
-
-
-class entitle_consume(LDAPUpdate):
-    __doc__ = _('Consume an entitlement.')
-
-    operation="consume entitlement"
-
-    msg_summary = _('Consumed %(value)s entitlement(s).')
-
-    takes_args = (
-        Int('quantity',
-            label=_('Quantity'),
-            minvalue=1,
-        ),
-    )
-
-    # We don't want rights or add/setattr
-    takes_options = (
-        # LDAPUpdate requires at least one option so autofill one
-        # This isn't otherwise used.
-        Int('hidden',
-            label=_('Quantity'),
-            minvalue=1,
-            autofill=True,
-            default=1,
-            flags=['no_option', 'no_output']
-        ),
-    )
-
-    has_output_params = output_params + (
-        Str('product',
-            label=_('Product'),
-        ),
-        Int('consumed',
-            label=_('Consumed'),
-        ),
-    )
-
-    def execute(self, *keys, **options):
-        """
-        Override this so we can set value to the number of entitlements
-        consumed.
-        """
-        result = super(entitle_consume, self).execute(*keys, **options)
-        result['value'] = unicode(keys[-1])
-        return result
-
-    def pre_callback(self, ldap, dn, entry_attrs, attrs_list, *keys, **options):
-        assert isinstance(dn, DN)
-        quantity = keys[-1]
-
-        os.environ['LANG'] = 'en_US'
-        locale.setlocale(locale.LC_ALL, '')
-
-        (db, uuid, certfile, keyfile) = get_uuid(ldap)
-        entry_attrs['ipaentitlementid'] = uuid
-        dn = ldap.make_dn(
-            entry_attrs, self.obj.uuid_attribute, self.obj.container_dn
-        )
-        if db is None:
-            raise errors.NotRegisteredError()
-        try:
-            (pool, uuid) = get_pool(ldap)
-
-            result=api.Command['entitle_status']()['result']
-            available = result['quantity'] - result['consumed']
-
-            if quantity > available:
-                raise errors.ValidationError(
-                    name='quantity',
-                    error=_('There are only %d entitlements left') % available)
-
-            try:
-                cp = UEPConnection(handler='/candlepin', cert_file=certfile, key_file=keyfile)
-                cp.bindByEntitlementPool(uuid, pool['id'], quantity=quantity)
-            except RestlibException, e:
-                raise errors.ACIError(info=e.msg)
-            results = cp.getCertificates(uuid)
-            usercertificate = []
-            for cert in results:
-                usercertificate.append(x509.normalize_certificate(cert['cert']))
-            entry_attrs['usercertificate'] = usercertificate
-            entry_attrs['ipaentitlementid'] = uuid
-        finally:
-            if db:
-                shutil.rmtree(db, ignore_errors=True)
-
-        return dn
-
-    def post_callback(self, ldap, dn, entry_attrs, *keys, **options):
-        """
-        Returning the certificates isn't very interesting. Return the
-        status of entitlements instead.
-        """
-        assert isinstance(dn, DN)
-        if 'usercertificate' in entry_attrs:
-            del entry_attrs['usercertificate']
-        if 'userpkcs12' in entry_attrs:
-            del entry_attrs['userpkcs12']
-        result = api.Command['entitle_status']()
-        for attr in result['result']:
-            entry_attrs[attr] = result['result'][attr]
-
-        return dn
-
-api.register(entitle_consume)
-
-
-class entitle_get(VirtualCommand):
-    __doc__ = _('Retrieve the entitlement certs.')
-
-    operation="retrieve entitlement"
-
-    has_output_params = (
-        Str('product',
-            label=_('Product'),
-        ),
-        Int('quantity',
-            label=_('Quantity'),
-        ),
-        Str('start',
-            label=_('Start'),
-        ),
-        Str('end',
-            label=_('End'),
-        ),
-        Str('serial',
-            label=_('Serial Number'),
-        ),
-    )
-
-    has_output = output.standard_list_of_entries
-
-    def execute(self, *keys, **kw):
-        ldap = self.api.Backend.ldap2
-
-        os.environ['LANG'] = 'en_US'
-        locale.setlocale(locale.LC_ALL, '')
-
-        (db, uuid, certfile, keyfile) = get_uuid(ldap)
-        if db is None:
-            quantity = 0
-            product = ''
-            registrations = api.Command['entitle_find'](all=True)['result'][0]
-            certs = []
-            if u'usercertificate' in registrations:
-                # make it look like a UEP cert
-                for cert in registrations['usercertificate']:
-                    certs.append(dict(cert = x509.make_pem(base64.b64encode(cert))))
-        else:
-            try:
-                cp = UEPConnection(handler='/candlepin', cert_file=certfile, key_file=keyfile)
-                certs = cp.getCertificates(uuid)
-            finally:
-                if db:
-                    shutil.rmtree(db, ignore_errors=True)
-
-        entries = []
-        for c in certs:
-            try:
-                pc = EntitlementCertificate(c['cert'])
-            except M2Crypto.X509.X509Error:
-                raise errors.CertificateFormatError(error=_('Not an entitlement certificate'))
-            order = pc.getOrder()
-            quantity = 0
-            if order.getQuantityUsed():
-                quantity = order.getQuantityUsed()
-            result={'product': unicode(order.getName()),
-                    'quantity': int(order.getQuantityUsed()),
-                    'start': unicode(order.getStart()),
-                    'end': unicode(order.getEnd()),
-                    'serial': unicode(pc.serialNumber()),
-                    'certificate': unicode(c['cert']),
-            }
-            entries.append(result)
-            del pc
-            del order
-
-        return dict(
-            result=entries,
-            count=len(entries),
-            truncated=False,
-        )
-
-api.register(entitle_get)
-
-class entitle_find(LDAPSearch):
-    __doc__ = _('Search for entitlement accounts.')
-
-    has_output_params = output_params
-    INTERNAL = True
-
-    def post_callback(self, ldap, entries, truncated, *args, **options):
-        if len(entries) == 0:
-            raise errors.NotRegisteredError()
-        return truncated
-
-api.register(entitle_find)
-
-class entitle_register(LDAPCreate):
-    __doc__ = _('Register to the entitlement system.')
-
-    operation="register entitlement"
-
-    msg_summary = _('Registered to entitlement server.')
-
-    takes_args = (
-        Str('username',
-            label=_('Username'),
-        ),
-    )
-
-    takes_options = LDAPCreate.takes_options + (
-        Str('ipaentitlementid?',
-            label='UUID',
-            doc=_('Enrollment UUID (not implemented)'),
-            flags=['no_create', 'no_update'],
-        ),
-        Password('password',
-            label=_('Password'),
-            doc=_('Registration password'),
-            confirm=False,
-        ),
-    )
-
-    """
-    has_output_params = (
-    )
-
-    has_output = (
-        Output('result',
-            type=dict,
-            doc=_('Dictionary mapping variable name to value'),
-        ),
-    )
-    """
-
-    def pre_callback(self, ldap, dn, entry_attrs, attrs_list, *keys, **options):
-        dn = DN(self.obj.container_dn, self.api.env.basedn)
-        if not ldap.can_add(dn):
-            raise errors.ACIError(info=_('No permission to register'))
-        os.environ['LANG'] = 'en_US'
-        locale.setlocale(locale.LC_ALL, '')
-
-        if 'ipaentitlementid' in options:
-            raise errors.ValidationError(name='ipaentitlementid',
-                error=_('Registering to specific UUID is not supported yet.'))
-
-        try:
-            registrations = api.Command['entitle_find']()
-            raise errors.AlreadyRegisteredError()
-        except errors.NotRegisteredError:
-            pass
-        try:
-            admin_cp = UEPConnection(handler='/candlepin', username=keys[-1], password=options.get('password'))
-            result = admin_cp.registerConsumer(name=api.env.realm, type="domain")
-            uuid = result['uuid']
-            db = None
-            try:
-                # Create a PKCS#12 file to store the private key and
-                # certificate in LDAP. Encrypt using the Apache cert
-                # database password.
-                db = tempfile.mkdtemp(prefix = "tmp-")
-                write_file(db + '/in.cert', result['idCert']['cert'])
-                write_file(db + '/in.key', result['idCert']['key'])
-                args = ['/usr/bin/openssl', 'pkcs12',
-                        '-export',
-                        '-in', db + '/in.cert',
-                        '-inkey', db + '/in.key',
-                        '-out', db + '/out.p12',
-                        '-name', 'candlepin',
-                        '-passout', 'pass:%s' % read_pkcs12_pin()
-                       ]
-
-                (stdout, stderr, rc) = run(args, raiseonerr=False)
-                pkcs12 = read_file(db + '/out.p12')
-
-                entry_attrs['ipaentitlementid'] = uuid
-                entry_attrs['userpkcs12'] = pkcs12
-            finally:
-                if db is not None:
-                    shutil.rmtree(db, ignore_errors=True)
-        except RestlibException, e:
-            if e.code == 401:
-                raise errors.ACIError(info=e.msg)
-            else:
-                raise e
-        except socket.gaierror:
-            raise errors.ACIError(info=e.args[1])
-
-        dn = ldap.make_dn(
-            entry_attrs, self.obj.uuid_attribute, self.obj.container_dn
-        )
-        return dn
-
-api.register(entitle_register)
-
-
-class entitle_import(LDAPUpdate):
-    __doc__ = _('Import an entitlement certificate.')
-
-    has_output_params = (
-        Str('product',
-            label=_('Product'),
-        ),
-        Int('quantity',
-            label=_('Quantity'),
-        ),
-        Int('consumed',
-            label=_('Consumed'),
-        ),
-    )
-
-    has_output = (
-        Output('result',
-            type=dict,
-            doc=_('Dictionary mapping variable name to value'),
-        ),
-    )
-
-    takes_args = (
-        File('usercertificate*', validate_certificate,
-            cli_name='certificate_file',
-        ),
-    )
-
-    # any update requires at least 1 option to be set so force an invisible
-    # one here by setting the uuid.
-    takes_options = LDAPCreate.takes_options + (
-        Str('uuid?',
-            label=_('UUID'),
-            doc=_('Enrollment UUID'),
-            flags=['no_create', 'no_update'],
-            autofill=True,
-            default=u'IMPORTED',
-        ),
-    )
-
-    def pre_callback(self, ldap, dn, entry_attrs, attrs_list, *keys, **options):
-        assert isinstance(dn, DN)
-        try:
-            (db, uuid, certfile, keyfile) = get_uuid(ldap)
-            if db is not None:
-                raise errors.AlreadyRegisteredError()
-        except errors.NotRegisteredError:
-            pass
-
-        try:
-            entry_attrs['ipaentitlementid'] = unicode('IMPORTED')
-            newcert = x509.normalize_certificate(keys[-1][0])
-            cert = x509.make_pem(base64.b64encode(newcert))
-            try:
-                pc = EntitlementCertificate(cert)
-                o = pc.getOrder()
-                if o is None:
-                    raise errors.CertificateFormatError(error=_('Not an entitlement certificate'))
-            except M2Crypto.X509.X509Error:
-                raise errors.CertificateFormatError(error=_('Not an entitlement certificate'))
-            dn = DN(('ipaentitlementid', entry_attrs['ipaentitlementid']), dn)
-            (dn, current_attrs) = ldap.get_entry(
-                dn, ['*'], normalize=self.obj.normalize_dn
-            )
-            entry_attrs['usercertificate'] = current_attrs['usercertificate']
-            entry_attrs['usercertificate'].append(newcert)
-        except errors.NotFound:
-            # First import, create the entry
-            entry_attrs['ipaentitlementid'] = unicode('IMPORTED')
-            entry_attrs['objectclass'] = self.obj.object_class
-            entry_attrs['usercertificate'] = x509.normalize_certificate(keys[-1][0])
-            ldap.add_entry(dn, entry_attrs)
-            setattr(context, 'entitle_import', True)
-
-        return dn
-
-    def exc_callback(self, keys, options, exc, call_func, *call_args, **call_kwargs):
-        """
-        If we are adding the first entry there are no updates so EmptyModlist
-        will get thrown. Ignore it.
-        """
-        if call_func.func_name == 'update_entry':
-            if isinstance(exc, errors.EmptyModlist):
-                if not getattr(context, 'entitle_import', False):
-                    raise exc
-                return (call_args, {})
-        raise exc
-
-    def execute(self, *keys, **options):
-        super(entitle_import, self).execute(*keys, **options)
-
-        return dict(
-            result=api.Command['entitle_status']()['result']
-        )
-
-api.register(entitle_import)
-
-class entitle_sync(LDAPUpdate):
-    __doc__ = _('Re-sync the local entitlement cache with the entitlement server.')
-
-    operation="sync entitlement"
-
-    msg_summary = _('Entitlement(s) synchronized.')
-
-    # We don't want rights or add/setattr
-    takes_options = (
-        # LDAPUpdate requires at least one option so autofill one
-        # This isn't otherwise used.
-        Int('hidden',
-            label=_('Quantity'),
-            minvalue=1,
-            autofill=True,
-            default=1,
-            flags=['no_option', 'no_output']
-        ),
-    )
-
-    has_output_params = output_params + (
-        Str('product',
-            label=_('Product'),
-        ),
-        Int('consumed',
-            label=_('Consumed'),
-        ),
-    )
-
-    def pre_callback(self, ldap, dn, entry_attrs, attrs_list, *keys, **options):
-        assert isinstance(dn, DN)
-        os.environ['LANG'] = 'en_US'
-        locale.setlocale(locale.LC_ALL, '')
-
-        (db, uuid, certfile, keyfile) = get_uuid(ldap)
-        if db is None:
-            raise errors.NotRegisteredError()
-        try:
-            (pool, uuid) = get_pool(ldap)
-
-            cp = UEPConnection(handler='/candlepin', cert_file=certfile, key_file=keyfile)
-            results = cp.getCertificates(uuid)
-            usercertificate = []
-            for cert in results:
-                usercertificate.append(x509.normalize_certificate(cert['cert']))
-            entry_attrs['usercertificate'] = usercertificate
-            entry_attrs['ipaentitlementid'] = uuid
-        finally:
-            if db:
-                shutil.rmtree(db, ignore_errors=True)
-
-        dn = ldap.make_dn(
-            entry_attrs, self.obj.uuid_attribute, self.obj.container_dn
-        )
-        return dn
-
-    def post_callback(self, ldap, dn, entry_attrs, *keys, **options):
-        """
-        Returning the certificates isn't very interesting. Return the
-        status of entitlements instead.
-        """
-        assert isinstance(dn, DN)
-        if 'usercertificate' in entry_attrs:
-            del entry_attrs['usercertificate']
-        if 'userpkcs12' in entry_attrs:
-            del entry_attrs['userpkcs12']
-        result = api.Command['entitle_status']()
-        for attr in result['result']:
-            entry_attrs[attr] = result['result'][attr]
-
-        return dn
-
-    def exc_callback(self, keys, options, exc, call_func, *call_args, **call_kwargs):
-        if call_func.func_name == 'update_entry':
-            if isinstance(exc, errors.EmptyModlist):
-                # If there is nothing to change we are already synchronized.
-                return
-        raise exc
-
-api.register(entitle_sync)
diff --git a/ipalib/plugins/internal.py b/ipalib/plugins/internal.py
index 09e08be..8ce67b3 100644
--- a/ipalib/plugins/internal.py
+++ b/ipalib/plugins/internal.py
@@ -387,27 +387,6 @@ class i18n_messages(Command):
                 "add_permission":_("Add Permission"),
                 "remove_permission": _("Remove Permission"),
             },
-            "entitle": {
-                "account": _("Account"),
-                "certificate": _("Certificate"),
-                "certificates": _("Certificates"),
-                "consume": _("Consume"),
-                "consume_entitlement": _("Consume Entitlement"),
-                "consumed": _("Consumed"),
-                "download": _("Download"),
-                "download_certificate": _("Download Certificate"),
-                "end": _("End"),
-                "import_button": _("Import"),
-                "import_certificate": _("Import Certificate"),
-                "import_message": _("Enter the Base64-encoded entitlement certificate below:"),
-                "loading": _("Loading..."),
-                "no_certificate": _("No Certificate."),
-                "product": _("Product"),
-                "register": _("Register"),
-                "registration": _("Registration"),
-                "start": _("Start"),
-                "status": _("Status"),
-            },
             "group": {
                 "details": _("Group Settings"),
                 "external": _("External"),
-- 
1.7.1

