From 883b5b9b6e5b1f9a206ee1fc0e865138b7d9d524 Mon Sep 17 00:00:00 2001
From: Martin Kosek <mkosek@redhat.com>
Date: Mon, 5 Aug 2013 08:28:09 +0200
Subject: [PATCH] ipa-kdb: remove memory leaks

All known memory leaks caused by unfreed allocated memory or unfreed
LDAP results (which should be also done after unsuccessful searches)
are fixed.

https://fedorahosted.org/freeipa/ticket/3413
---
 daemons/ipa-kdb/ipa_kdb.c        |  4 ++++
 daemons/ipa-kdb/ipa_kdb.h        |  2 ++
 daemons/ipa-kdb/ipa_kdb_common.c | 13 +++++++++++--
 daemons/ipa-kdb/ipa_kdb_mspac.c  |  8 ++++++++
 4 files changed, 25 insertions(+), 2 deletions(-)

diff --git a/daemons/ipa-kdb/ipa_kdb.c b/daemons/ipa-kdb/ipa_kdb.c
index 3527cefa10df67d3f17c730ab4483410c736a44f..55a932abdc3aeaa48892715196834a25f9b2c0e1 100644
--- a/daemons/ipa-kdb/ipa_kdb.c
+++ b/daemons/ipa-kdb/ipa_kdb.c
@@ -40,10 +40,14 @@ static void ipadb_context_free(krb5_context kcontext,
 {
     if (*ctx != NULL) {
         free((*ctx)->uri);
+        free((*ctx)->base);
+        free((*ctx)->realm_base);
         /* ldap free lcontext */
         if ((*ctx)->lcontext) {
             ldap_unbind_ext_s((*ctx)->lcontext, NULL, NULL);
         }
+        free((*ctx)->supp_encs);
+        ipadb_mspac_struct_free(&(*ctx)->mspac);
         krb5_free_default_realm(kcontext, (*ctx)->realm);
         free(*ctx);
         *ctx = NULL;
diff --git a/daemons/ipa-kdb/ipa_kdb.h b/daemons/ipa-kdb/ipa_kdb.h
index 0a179dbcf0e9c17c0eb468638cd7436dc60d31a5..2c54c895ad9094a11f31e8d496435f30e9eb8397 100644
--- a/daemons/ipa-kdb/ipa_kdb.h
+++ b/daemons/ipa-kdb/ipa_kdb.h
@@ -235,6 +235,8 @@ krb5_error_code ipadb_sign_authdata(krb5_context context,
 
 krb5_error_code ipadb_reinit_mspac(struct ipadb_context *ipactx);
 
+void ipadb_mspac_struct_free(struct ipadb_mspac **mspac);
+
 /* DELEGATION CHECKS */
 
 krb5_error_code ipadb_check_allowed_to_delegate(krb5_context kcontext,
diff --git a/daemons/ipa-kdb/ipa_kdb_common.c b/daemons/ipa-kdb/ipa_kdb_common.c
index 71df9634c4e25378494b165db9a9381f2b8fc206..2311ee154285e1c14b1cce0a893dd32de3904d2a 100644
--- a/daemons/ipa-kdb/ipa_kdb_common.c
+++ b/daemons/ipa-kdb/ipa_kdb_common.c
@@ -172,7 +172,7 @@ krb5_error_code ipadb_simple_search(struct ipadb_context *ipactx,
     /* first test if we need to retry to connect */
     if (ret != 0 &&
         ipadb_need_retry(ipactx, ret)) {
-
+        ldap_msgfree(*res);
         ret = ldap_search_ext_s(ipactx->lcontext, basedn, scope,
                                 filter, attrs, 0, NULL, NULL,
                                 &std_timeout, LDAP_NO_LIMIT,
@@ -283,6 +283,7 @@ krb5_error_code ipadb_deref_search(struct ipadb_context *ipactx,
     int times;
     int ret;
     int c;
+    bool retry;
 
     for (c = 0; deref_attr_names[c]; c++) {
         /* count */ ;
@@ -314,7 +315,8 @@ krb5_error_code ipadb_deref_search(struct ipadb_context *ipactx,
     /* retry once if connection errors (tot. max. 2 tries) */
     times = 2;
     ret = LDAP_SUCCESS;
-    while (!ipadb_need_retry(ipactx, ret) && times > 0) {
+    retry = true;
+    while (retry) {
         times--;
         ret = ldap_search_ext_s(ipactx->lcontext, base_dn,
                                 scope, filter,
@@ -322,11 +324,18 @@ krb5_error_code ipadb_deref_search(struct ipadb_context *ipactx,
                                 ctrl, NULL,
                                 &std_timeout, LDAP_NO_LIMIT,
                                 res);
+        retry = !ipadb_need_retry(ipactx, ret) && times > 0;
+
+        if (retry) {
+            /* Free result before next try */
+            ldap_msgfree(*res);
+        }
     }
 
     kerr = ipadb_simple_ldap_to_kerr(ret);
 
 done:
+    ldap_control_free(ctrl[0]);
     ldap_memfree(derefval.bv_val);
     free(ds);
     return kerr;
diff --git a/daemons/ipa-kdb/ipa_kdb_mspac.c b/daemons/ipa-kdb/ipa_kdb_mspac.c
index f00de7bf1148f8f3f58ae4956ac07e4b4195a481..fe9050cfbe98d5770b27b75c9a44538ee83bd199 100644
--- a/daemons/ipa-kdb/ipa_kdb_mspac.c
+++ b/daemons/ipa-kdb/ipa_kdb_mspac.c
@@ -970,6 +970,7 @@ static int map_groups(TALLOC_CTX *memctx, krb5_context kcontext,
             goto done;
         }
 
+        ldap_msgfree(results);
         kerr = ipadb_deref_search(ipactx, basedn, LDAP_SCOPE_ONE, filter,
                                   entry_attrs, deref_search_attrs,
                                   memberof_pac_attrs, &results);
@@ -1668,12 +1669,14 @@ krb5_error_code ipadb_sign_authdata(krb5_context context,
     ad.ad_type = KRB5_AUTHDATA_WIN2K_PAC;
     ad.contents = (krb5_octet *)pac_data.data;
     ad.length = pac_data.length;
+
     authdata[0] = &ad;
 
     kerr = krb5_encode_authdata_container(context,
                                           KRB5_AUTHDATA_IF_RELEVANT,
                                           authdata,
                                           signed_auth_data);
+    krb5_free_data_contents(context, &pac_data);
     if (kerr != 0) {
         goto done;
     }
@@ -1724,12 +1727,14 @@ void ipadb_mspac_struct_free(struct ipadb_mspac **mspac)
             free((*mspac)->trusts[i].flat_name);
             free((*mspac)->trusts[i].domain_sid);
         }
+        free((*mspac)->trusts);
     }
 
     if ((*mspac)->well_known_sids) {
         free((*mspac)->well_known_sids);
     }
 
+    free(*mspac);
     *mspac = NULL;
 }
 
@@ -1953,14 +1958,17 @@ krb5_error_code ipadb_reinit_mspac(struct ipadb_context *ipactx)
             if (ret == 0) {
                 ret = string_to_sid(resstr, &gsid);
                 if (ret) {
+                    free(resstr);
                     kerr = ret;
                     goto done;
                 }
                 ret = sid_split_rid(&gsid, &ipactx->mspac->fallback_rid);
                 if (ret) {
+                    free(resstr);
                     kerr = ret;
                     goto done;
                 }
+                free(resstr);
             }
         }
     }
-- 
1.8.3.1

